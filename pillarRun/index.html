<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>RED BALLS MUST BOUNCE</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script src="../assets/three/three.js" type="text/javascript"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const timeStep = 0.01
        const ball = {
            x: 0,
            y: 0,
            z: -150,
            radius: 5,
            color: 0xf00,
            velocity: {
                x: 0,
                y: 0,
                z: -2
            }
        };
        const lightColor = 0xdddddd
        const trail = []
        const trailSize = 70
        const splashSpeed = 2
        const gridSize = 10000
        const obstacles = []
        const obstaclesPer10K = 300
        const obstacleSpacing = 10000/obstaclesPer10K
        const obstacleSize = 100
        const obstacleSpread = 1000
        const obstacleColor = 0xffffff
        let ksCompleted = 0
        let directionChange = 0
        let steeringPower = 0.2

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.set(0, 120, 0);
        camera.rotation.set(-Math.PI/8, 0, 0);
        //Add red ball
        const sphereGeometry = new THREE.SphereGeometry(ball.radius, 32, 32);
        const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        const gridHelper = new THREE.GridHelper(gridSize, gridSize/10);
        gridHelper.position.set(0, 0, 0);
        scene.add(gridHelper);

        const light = new THREE.PointLight(lightColor, 2)
        light.position.set(10, 10, 10)
        scene.add(light)

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(trail);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        const splashGeometry = new THREE.CircleGeometry(10, 32);
        const splashMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const splash = new THREE.Mesh(splashGeometry, splashMaterial);
        splash.rotation.set(-Math.PI/2, 0, 0);
        scene.add(splash);

        const fog = new THREE.Fog(0x000000, 500, 1000);
        scene.fog = fog;

        const updateBallPosition = () => {
            //Move ball
            ball.x += ball.velocity.x;
            ball.y += ball.velocity.y;
            ball.z += ball.velocity.z;
            
            if(ball.z < -(ksCompleted * 1000) - 1000) {
                ksCompleted += 1
                gridHelper.position.set(0, 0, -(ksCompleted * 1000) - 1000)
                ball.velocity.z -= 0.2
            }

            if(sphere.position.y - ball.radius < 0) {
                ball.velocity.y = 4
                ball.y = ball.radius;

                splash.position.set(ball.x, 0, ball.z);
                splash.geometry = new THREE.CircleGeometry(0, 32);
            } else {
                ball.velocity.y -= 9.82 * timeStep;
            }

            trail.push({
                x: ball.x,
                y: ball.y,
                z: ball.z
            })

            if(trail.length > trailSize) {
                trail.shift();
            }
            sphere.position.set(ball.x, ball.y, ball.z)
            camera.position.x = ball.x
            camera.position.z = ball.z + 120
            light.position.set(ball.x, ball.y + 50, ball.z)
        };

        const updateSplash = () => {
            const size = splash.geometry.parameters.radius;
            const opacity = scaleValue(size, 0, 40, 1, 0)
            const newGeometry = new THREE.CircleGeometry(size + splashSpeed, 32);
            splash.geometry = newGeometry;
            splash.material.transparent = true;
            splash.material.opacity = opacity;
        }

        const addObstacle = () => {
            const s = obstacles.length
            const lastObstacleIsBehindBall = s > 0 ? (obstacles[0].position.z > ball.z + 200) : false
            if(lastObstacleIsBehindBall || obstacles.length < obstaclesPer10K){
                const newX = ball.x + scaleValue(Math.random(), 0, 1, -obstacleSpread, obstacleSpread)
                let newZ = ball.z - 2000
                if(obstacles.length > 0){
                    newZ = obstacles[s - 1].position.z - scaleValue(Math.random(), 0, 1, obstacleSpacing, 2*obstacleSpacing)
                }
                if(lastObstacleIsBehindBall){
                    removeObstacle()
                }
                const obstacle = {
                    x: newX,
                    y: 0,
                    z: newZ,
                    size: obstacleSize,
                }
                const obstacleGeometry = new THREE.BoxGeometry(obstacle.size, obstacle.size * 10, obstacle.size)
                const obstacleMaterial = new THREE.MeshPhongMaterial({ color: obstacleColor});
                const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacleMesh.position.set(obstacle.x, obstacle.y, obstacle.z);
                scene.add(obstacleMesh);
                obstacles.push(obstacleMesh)
            }
        }

        const removeObstacle = () => {
            if(obstacles.length > 0){
                const obstacle = obstacles.shift()
                scene.remove(obstacle)
            }
        }

        const checkCollision = () => {
            for(let i = 0; i < obstacles.length; i++){
                const obstacle = obstacles[i]
                if(obstacle.position.z < (ball.z - obstacleSize - ball.radius)){
                    break
                }
                if (Math.abs(obstacle.position.z - ball.z) < obstacleSize/2 + ball.radius) {
                    if (Math.abs(obstacle.position.x - ball.x) < obstacleSize/2 + ball.radius) {
                        alert("You lost!")
                        break; 
                    }
                }

            }
        }

        const addTrail = () => {
            const geometry = new THREE.BufferGeometry().setFromPoints(trail);
            line.geometry.dispose();
            line.geometry = geometry;
        }

        const scaleValue = (value, min, max, targetMin = 0, targetMax = 1) => {
            value = Math.max(min, value);
            value = Math.min(max, value);
            return (value - min) * (targetMax - targetMin) / (max - min) + targetMin;
        }

        const render = () => {
            addTrail()
            updateBallPosition()
            updateSplash()
            addObstacle()
            checkCollision()
            renderer.render(scene, camera);
        };

        function go() {
            render()
            requestAnimationFrame(go);
        };
        go()
        render()
        // setInterval(render, 1000);

        //Key handler
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'ArrowLeft':
                    ball.velocity.x -= steeringPower;
                    break;
                case 'ArrowRight':
                    ball.velocity.x += steeringPower;
                    break;
            }
        });
    </script>
</body>

</html>